"""GESTIMA - G-code Generator & Toolpath Time Calculator

Generates ISO 6983 G-code (Fanuc dialect) from ToolMove sequences.
Also calculates authoritative machining time directly from toolpath moves.

G-code dialects:
- Fanuc (default): G28, G96/G97, G32 threading
- Sinumerik: LIMS, G33, CYCLE95 (future)

Time calculation:
- G00 (rapid): distance / rapid_feedrate
- G01 (linear): distance / (RPM × feed)
- G02/G03 (arc): arc_length / (RPM × feed)
- G32 (thread): length / (RPM × pitch)

Coordinate system:
- X = diameter (positive), Z = length (0 = face, negative = into part)
- All values in mm
"""

import math
from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass

from app.services.toolpath_generator import ToolMove


# Machine defaults
RAPID_FEEDRATE = 15000  # mm/min — typical CNC lathe rapid traverse
TOOL_CHANGE_SEC = 5.0   # Approximate tool change time


@dataclass
class GCodeProgram:
    """Complete G-code program with metadata."""
    lines: List[str]                # G-code lines
    total_time_sec: float           # Total machining time
    cutting_time_sec: float         # Only cutting moves (G01/G02/G03/G32)
    rapid_time_sec: float           # Only rapid moves (G00)
    num_moves: int                  # Total move count
    num_cutting_moves: int          # Cutting move count
    total_path_length_mm: float     # Total tool path distance


def generate_gcode(
    moves: List[ToolMove],
    program_number: int = 1,
    part_name: str = "",
    tool_number: int = 1,
    tool_name: str = "VNĚJŠÍ NŮŽ",
    use_css: bool = True,
) -> GCodeProgram:
    """
    Generate Fanuc-compatible G-code from toolpath moves.

    Args:
        moves: List of ToolMove from toolpath_generator
        program_number: O-number (O0001)
        part_name: Part name/number for header comment
        tool_number: T-number (T0101)
        tool_name: Tool description for comment
        use_css: Use G96 (constant surface speed) vs G97 (constant RPM)

    Returns:
        GCodeProgram with lines, timing, and statistics
    """
    lines = []
    total_time = 0.0
    cutting_time = 0.0
    rapid_time = 0.0
    num_cutting = 0
    total_path = 0.0

    # Track current position for distance calculation
    cur_x: Optional[float] = None
    cur_y: Optional[float] = None
    cur_z: Optional[float] = None
    cur_s: Optional[int] = None

    # Header
    lines.append(f"O{program_number:04d} ({part_name or 'GESTIMA'})")
    lines.append(f"(GENERATED BY GESTIMA CAM)")
    lines.append(f"(TOOL: T{tool_number:02d} - {tool_name})")
    lines.append("")

    # Safety block
    lines.append("N10 G28 U0 W0 (Home)")
    lines.append(f"N20 T{tool_number:02d}{tool_number:02d} (Tool call)")

    # Spindle mode
    if use_css and moves:
        # Find first cutting move with speed
        first_s = next((m.s for m in moves if m.s and m.code != "G00"), None)
        if first_s:
            # G96 S = Vc in m/min (approx from RPM at mid-diameter)
            lines.append(f"N30 G96 S{first_s} M03 (CSS ON, CW)")
            lines.append(f"N40 G50 S4000 (Max RPM clamp)")

    line_num = 50

    for move in moves:
        parts = []

        # G-code
        parts.append(move.code)

        # X coordinate (diameter)
        if move.x is not None:
            parts.append(f"X{move.x:.3f}")

        # Y coordinate (milling only)
        if move.y is not None:
            parts.append(f"Y{move.y:.3f}")

        # Z coordinate
        if move.z is not None:
            parts.append(f"Z{move.z:.3f}")

        # Arc center (I, K) for G02/G03
        if move.code in ("G02", "G03"):
            if move.i is not None:
                parts.append(f"I{move.i:.3f}")
            if move.k is not None:
                parts.append(f"K{move.k:.3f}")

        # Feed
        if move.f is not None and move.code in ("G01", "G02", "G03", "G32"):
            parts.append(f"F{move.f:.3f}")

        # Spindle speed (only if changed)
        if move.s is not None and move.s != cur_s and move.code != "G00":
            parts.append(f"S{move.s}")
            cur_s = move.s

        # Comment
        if move.comment:
            parts.append(f"({move.comment})")

        lines.append(f"N{line_num} {' '.join(parts)}")
        line_num += 10

        # === TIME CALCULATION from move ===
        move_dist, move_time = _calc_move_time(
            move, cur_x, cur_z, cur_y
        )
        total_path += move_dist

        if move.code == "G00":
            rapid_time += move_time
        else:
            cutting_time += move_time
            num_cutting += 1

        total_time += move_time

        # Update position
        if move.x is not None:
            cur_x = move.x
        if move.y is not None:
            cur_y = move.y
        if move.z is not None:
            cur_z = move.z

    # Footer
    lines.append("")
    lines.append(f"N{line_num} G28 U0 W0 (Home)")
    line_num += 10
    lines.append(f"N{line_num} M30 (Program end)")

    # Summary comment
    lines.append("")
    lines.append(f"(CUTTING TIME: {cutting_time:.1f}s = {cutting_time/60:.2f}min)")
    lines.append(f"(RAPID TIME: {rapid_time:.1f}s)")
    lines.append(f"(TOTAL TIME: {total_time:.1f}s = {total_time/60:.2f}min)")
    lines.append(f"(PATH LENGTH: {total_path:.1f}mm)")

    return GCodeProgram(
        lines=lines,
        total_time_sec=total_time,
        cutting_time_sec=cutting_time,
        rapid_time_sec=rapid_time,
        num_moves=len(moves),
        num_cutting_moves=num_cutting,
        total_path_length_mm=total_path,
    )


def _calc_move_time(
    move: ToolMove,
    prev_x: Optional[float],
    prev_z: Optional[float],
    prev_y: Optional[float] = None,
) -> Tuple[float, float]:
    """
    Calculate distance and time for a single move.

    Returns:
        (distance_mm, time_sec)
    """
    # Calculate distance
    dx = (move.x - prev_x) if (move.x is not None and prev_x is not None) else 0
    dy = (move.y - prev_y) if (move.y is not None and prev_y is not None) else 0
    dz = (move.z - prev_z) if (move.z is not None and prev_z is not None) else 0

    # For X: distance is in radius (half of diameter change) for lathe operations
    # For milling (when Y is present), X is linear position
    if move.y is None:
        dx_radius = dx / 2  # Lathe: X is diameter
    else:
        dx_radius = dx  # Milling: X is linear

    if move.code in ("G02", "G03"):
        # Arc: approximate arc length from radius
        # For quarter circle: π/2 × R
        r = math.sqrt(dx_radius**2 + dy**2 + dz**2) if (dx_radius or dy or dz) else 0
        if move.i is not None and move.k is not None:
            arc_r = math.sqrt((move.i / 2)**2 + move.k**2)
            distance = (math.pi / 2) * arc_r  # Quarter circle approximation
        else:
            distance = math.sqrt(dx_radius**2 + dy**2 + dz**2)
    else:
        distance = math.sqrt(dx_radius**2 + dy**2 + dz**2)

    if distance <= 0:
        return 0.0, 0.0

    # Calculate time based on move type
    if move.code == "G00":
        # Rapid: constant feedrate in mm/min
        time_sec = (distance / RAPID_FEEDRATE) * 60
    elif move.code == "G32":
        # Threading: F = pitch, time = length / (RPM × pitch) × 60
        if move.s and move.f:
            time_sec = (abs(dz) / (move.s * move.f)) * 60
        else:
            time_sec = 0
    elif move.code in ("G01", "G02", "G03"):
        # Cutting: F = feed mm/rev, time = distance / (RPM × feed) × 60
        if move.s and move.f:
            time_sec = (distance / (move.s * move.f)) * 60
        else:
            time_sec = 0
    else:
        time_sec = 0

    return distance, time_sec


def toolpath_to_text(program: GCodeProgram) -> str:
    """Convert GCodeProgram to plain text string."""
    return "\n".join(program.lines)


def generate_multi_tool_gcode(
    features: List[Dict],
    program_number: int = 1,
    part_name: str = "",
) -> GCodeProgram:
    """
    Generate complete G-code program for multiple features with tool changes.

    Args:
        features: List of dicts with keys:
            - feature_type: str
            - geometry: dict
            - Vc, f, Ap: cutting conditions
            - tool_number: int
            - tool_name: str

    Returns:
        Combined GCodeProgram for entire part
    """
    from app.services.toolpath_generator import generate_toolpath

    all_lines = []
    total_time = 0.0
    cutting_time = 0.0
    rapid_time = 0.0
    total_moves = 0
    total_cutting = 0
    total_path = 0.0

    # Header
    all_lines.append(f"O{program_number:04d} ({part_name or 'GESTIMA'})")
    all_lines.append("(GENERATED BY GESTIMA CAM)")
    all_lines.append("")
    all_lines.append("N10 G28 U0 W0 (Home)")

    line_num = 20
    prev_tool = None

    for feat in features:
        ft = feat.get("feature_type", "unknown")
        geo = feat.get("geometry", {})
        Vc = feat.get("Vc", 150)
        f_val = feat.get("f", 0.2)
        Ap = feat.get("Ap", 2.0)
        tool_num = feat.get("tool_number", 1)
        tool_name = feat.get("tool_name", ft)
        max_rpm = feat.get("max_rpm", 4000)

        # Generate toolpath for this feature
        # Branch: milling vs turning
        if ft.startswith('mill_') or ft.startswith('lt_'):
            # Milling toolpath generator
            from app.services.milling_toolpath_generator import generate_milling_toolpath
            tool_diameter = geo.get('tool_diameter', geo.get('to_diameter', 10.0))
            fz = f_val  # Feed per tooth for milling
            Ae = tool_diameter * 0.6  # Default 60% stepover
            moves = generate_milling_toolpath(
                feature_type=ft,
                geometry=geo,
                Vc=Vc,
                fz=fz,
                Ap=Ap,
                Ae=Ae,
                tool_diameter=tool_diameter,
                max_rpm=max_rpm,
            )
        else:
            # Turning toolpath generator
            moves = generate_toolpath(ft, geo, Vc, f_val, Ap, max_rpm)

        if not moves:
            continue

        # Tool change if needed
        if tool_num != prev_tool:
            all_lines.append("")
            all_lines.append(f"N{line_num} G28 U0 W0 (Home for tool change)")
            line_num += 10
            all_lines.append(
                f"N{line_num} T{tool_num:02d}{tool_num:02d} ({tool_name})"
            )
            line_num += 10
            total_time += TOOL_CHANGE_SEC
            prev_tool = tool_num

        # Add moves
        all_lines.append(f"(--- {ft.upper()}: {feat.get('note', '')} ---)")

        cur_x = None
        cur_y = None
        cur_z = None

        for move in moves:
            parts = [move.code]
            if move.x is not None:
                parts.append(f"X{move.x:.3f}")
            if move.y is not None:
                parts.append(f"Y{move.y:.3f}")
            if move.z is not None:
                parts.append(f"Z{move.z:.3f}")
            if move.code in ("G02", "G03"):
                if move.i is not None:
                    parts.append(f"I{move.i:.3f}")
                if move.k is not None:
                    parts.append(f"K{move.k:.3f}")
            if move.f is not None and move.code != "G00":
                parts.append(f"F{move.f:.3f}")
            if move.s is not None and move.code != "G00":
                parts.append(f"S{move.s}")
            if move.comment:
                parts.append(f"({move.comment})")

            all_lines.append(f"N{line_num} {' '.join(parts)}")
            line_num += 10

            dist, t = _calc_move_time(move, cur_x, cur_z, cur_y)
            total_path += dist
            if move.code == "G00":
                rapid_time += t
            else:
                cutting_time += t
                total_cutting += 1
            total_time += t
            total_moves += 1

            if move.x is not None:
                cur_x = move.x
            if move.y is not None:
                cur_y = move.y
            if move.z is not None:
                cur_z = move.z

    # Footer
    all_lines.append("")
    all_lines.append(f"N{line_num} G28 U0 W0 (Home)")
    line_num += 10
    all_lines.append(f"N{line_num} M30 (Program end)")
    all_lines.append("")
    all_lines.append(f"(CUTTING TIME: {cutting_time:.1f}s = {cutting_time/60:.2f}min)")
    all_lines.append(f"(RAPID TIME: {rapid_time:.1f}s)")
    all_lines.append(f"(TOTAL TIME: {total_time:.1f}s = {total_time/60:.2f}min)")
    all_lines.append(f"(PATH LENGTH: {total_path:.1f}mm)")

    return GCodeProgram(
        lines=all_lines,
        total_time_sec=total_time,
        cutting_time_sec=cutting_time,
        rapid_time_sec=rapid_time,
        num_moves=total_moves,
        num_cutting_moves=total_cutting,
        total_path_length_mm=total_path,
    )
