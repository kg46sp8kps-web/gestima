"""
STEP File Parser - Extract precise geometry from 3D CAD models
STEP format: ISO 10303-21 (text-based)

Approach:
1. Basic text parsing (fast, free)
2. Claude API for complex geometry (accurate, paid)
"""

import re
from typing import Dict, List, Optional, Tuple
from pathlib import Path
from dataclasses import dataclass
import math
import logging

from app.services.feature_utils import deduplicate_features

logger = logging.getLogger(__name__)


@dataclass
class StepFeature:
    """Manufacturing feature detected from STEP geometry"""
    type: str  # 'hole', 'thread', 'chamfer', 'cone', 'radius', ...
    params: Dict
    confidence: float = 1.0  # STEP is precise, so usually 1.0


class StepParser:
    """
    Hybrid STEP parser with OCCT and regex fallback.

    Tries OCCT first (accurate, native B-rep), falls back to regex (fast, basic).
    """

    def __init__(self, use_occt: bool = True):
        # Regex parser state
        self.entities = {}  # ID -> entity mapping
        self.features = []
        self.advanced_faces = {}  # surface_id -> {sense: 'T'/'F', face_id: int}
        self.rotation_axis = None  # Detected rotation axis ('x', 'y', 'z', or None)

        # OCCT parser (optional)
        self.use_occt = use_occt
        self.occt_parser = None

        if use_occt:
            try:
                from app.services.step_parser_occt import StepParserOCCT
                self.occt_parser = StepParserOCCT()
                logger.info("OCCT parser enabled")
            except ImportError:
                logger.warning("OCCT not available - using regex parser only")
                self.use_occt = False

    def parse_file(self, step_path: str) -> Dict:
        """
        Parse STEP file and extract manufacturing features.

        Tries OCCT first, falls back to regex on failure.

        Returns precise geometry (STEP is CAD-accurate)
        """
        # Try OCCT first
        if self.occt_parser:
            try:
                result = self.occt_parser.parse_file(step_path)
                if result.get('success'):
                    logger.info(f"OCCT parsed {len(result.get('features', []))} features")
                    return result
                else:
                    logger.warning(f"OCCT failed: {result.get('error')} - falling back to regex")
            except Exception as e:
                logger.error(f"OCCT parser exception: {e} - falling back to regex", exc_info=True)

        # Fallback: regex parser
        logger.info("Using regex parser")
        return self._parse_with_regex(step_path)

    def _parse_with_regex(self, step_path: str) -> Dict:
        """Original regex-based parser (fallback)."""
        try:
            content = Path(step_path).read_text(encoding='utf-8', errors='ignore')

            # 1. Parse basic STEP structure
            self._parse_step_entities(content)

            # 2. Parse advanced faces for inner/outer classification
            self._parse_advanced_faces()

            # 3. Extract geometric features (also detects rotation axis internally)
            features = self._extract_features()

            # 4. Use rotation axis detected during feature extraction
            rotation_axis = self.rotation_axis

            # 5. Calculate bounding box and basic properties
            metadata = self._extract_metadata(content)

            return {
                'success': True,
                'format': 'step',
                'metadata': metadata,
                'features': features,
                'advanced_faces': self.advanced_faces,
                'rotation_axis': rotation_axis,
                'confidence': 1.0,  # STEP is precise!
                'source': 'step_regex'
            }

        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'fallback': 'Use Claude API for complex STEP parsing'
            }

    def _parse_step_entities(self, content: str):
        """
        Parse STEP entities from DATA section

        Handles multi-line entities by normalizing the content first
        """
        # Find DATA section
        data_match = re.search(r'DATA;(.*?)ENDSEC;', content, re.DOTALL)
        if not data_match:
            return

        data_section = data_match.group(1)

        # Normalize multi-line entities: join continuation lines
        # STEP entities can span multiple lines. We need to remove ALL newlines
        # that are NOT followed by a new entity definition (#ID=).
        # Examples of multi-line entities:
        #   #87=CLOSED_SHELL('',(#149,#150,
        #     #159,#160));                     ← continuation with #refs
        #   #806=ADVANCED_FACE('',(#112,...),#770,
        #     .T.);                            ← continuation with sense flag
        # Strategy: remove newlines NOT followed by #digit= (which starts new entity)
        normalized = re.sub(r'\n(?!\s*#\d+=)', ' ', data_section)

        # Parse entities: #123=ENTITY_TYPE(...);
        # Support numbers in type names (e.g., AXIS2_PLACEMENT_3D)
        entity_pattern = r'#(\d+)\s*=\s*([A-Z_0-9]+)\s*\((.*?)\)\s*;'

        for match in re.finditer(entity_pattern, normalized):
            entity_id = int(match.group(1))
            entity_type = match.group(2)
            entity_params = match.group(3)

            self.entities[entity_id] = {
                'type': entity_type,
                'params': entity_params,
                'id': entity_id
            }

    def _resolve_ref(self, ref_str: str) -> Optional[int]:
        """Parse reference string '#123' to int 123"""
        match = re.match(r'#(\d+)', ref_str.strip())
        if match:
            return int(match.group(1))
        return None

    def _resolve_cartesian_point(self, entity_id: int) -> Optional[Tuple[float, float, float]]:
        """Get (x, y, z) from CARTESIAN_POINT entity"""
        entity = self.entities.get(entity_id)
        if not entity or entity['type'] != 'CARTESIAN_POINT':
            return None

        # Format: CARTESIAN_POINT('',(x,y,z))
        # Values may use scientific notation: 1.5E-15, -3.4E+02
        params = entity['params']
        numbers_match = re.search(r'\(([-+\deE.,\s]+)\)', params)
        if not numbers_match:
            return None

        numbers_str = numbers_match.group(1)
        numbers = re.findall(r'[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?', numbers_str)
        if len(numbers) >= 3:
            return (float(numbers[0]), float(numbers[1]), float(numbers[2]))
        return None

    def _resolve_direction(self, entity_id: int) -> Optional[Tuple[float, float, float]]:
        """Get (dx, dy, dz) from DIRECTION entity"""
        entity = self.entities.get(entity_id)
        if not entity or entity['type'] != 'DIRECTION':
            return None

        # Format: DIRECTION('',(dx,dy,dz))
        # Values may use scientific notation: 1.5E-15, -3.4E+02
        params = entity['params']
        numbers_match = re.search(r'\(([-+\deE.,\s]+)\)', params)
        if not numbers_match:
            return None

        numbers_str = numbers_match.group(1)
        numbers = re.findall(r'[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?', numbers_str)
        if len(numbers) >= 3:
            return (float(numbers[0]), float(numbers[1]), float(numbers[2]))
        return None

    def _resolve_placement(self, entity_id: int) -> Optional[Dict]:
        """
        Get placement data from AXIS2_PLACEMENT_3D entity

        Returns: {location: (x,y,z), axis: (dx,dy,dz), ref_dir: (dx,dy,dz)}
        """
        entity = self.entities.get(entity_id)
        if not entity or entity['type'] != 'AXIS2_PLACEMENT_3D':
            return None

        # Format: AXIS2_PLACEMENT_3D('',#location,#axis,#ref_dir)
        params = entity['params']
        refs = re.findall(r'#\d+', params)

        if len(refs) < 2:
            return None

        location_id = self._resolve_ref(refs[0])
        axis_id = self._resolve_ref(refs[1])
        ref_dir_id = self._resolve_ref(refs[2]) if len(refs) > 2 else None

        result = {}
        if location_id:
            result['location'] = self._resolve_cartesian_point(location_id)
        if axis_id:
            result['axis'] = self._resolve_direction(axis_id)
        if ref_dir_id:
            result['ref_dir'] = self._resolve_direction(ref_dir_id)

        return result if result else None

    def _parse_advanced_faces(self):
        """
        Parse ADVANCED_FACE entities to classify surfaces as inner/outer

        ADVANCED_FACE has sense flag: .T. = outer, .F. = inner (bore/hole)
        """
        for entity_id, entity in self.entities.items():
            if entity['type'] != 'ADVANCED_FACE':
                continue

            params = entity['params']

            # Extract surface reference (last #ID before sense flag)
            # Format: ADVANCED_FACE('',(#bounds...),#surface,.T/.F.);
            refs = re.findall(r'#\d+', params)
            if not refs:
                continue

            # Last ref is the surface
            surface_id = self._resolve_ref(refs[-1])

            # Extract sense flag (.T. or .F.)
            sense_match = re.search(r'\.([TF])\.', params)
            if not sense_match:
                continue

            sense = sense_match.group(1)

            if surface_id:
                self.advanced_faces[surface_id] = {
                    'sense': sense,
                    'face_id': entity_id
                }

    def _normalize_positions(self, features: List[Dict]) -> List[Dict]:
        """
        Normalize x/y/z positions relative to rotation axis center.

        STEP files use absolute coordinates - a part can be positioned anywhere
        in 3D space (e.g., x=225, y=930). For contour building, we need positions
        relative to the rotation axis (x=0, y=0 for z-axis parts).

        Strategy:
        1. Find largest cylinders with axis aligned with rotation_axis (main body)
        2. Use THEIR positions to find rotation axis center (excludes bolt holes)
        3. Translate all features so rotation axis is at origin

        This allows _is_off_axis() checks to work correctly (threshold = 1.0mm).
        """
        if not self.rotation_axis or not features:
            return features

        # Filter on-axis cylindrical features (main body surfaces)
        on_axis_cylinders = []
        for f in features:
            if f.get('type') != 'cylindrical':
                continue

            # Check if axis_direction aligns with rotation_axis
            axis_dir = f.get('axis_direction')
            if not axis_dir or not isinstance(axis_dir, tuple) or len(axis_dir) < 3:
                continue

            ax_idx = {'x': 0, 'y': 1, 'z': 2}.get(self.rotation_axis, 2)
            # On-axis: axis_direction has ±1 on rotation axis, ~0 elsewhere
            if abs(abs(axis_dir[ax_idx]) - 1.0) <= 0.1:
                if f.get('x_position') is not None and f.get('y_position') is not None:
                    on_axis_cylinders.append(f)

        if not on_axis_cylinders:
            # No on-axis cylinders with positions → cannot normalize
            logger.warning("No on-axis cylinders found for position normalization")
            return features

        # Find cylinder with largest "volume signature" (length × radius²)
        # This is most likely the main body, not bolt holes on bolt circle
        def volume_signature(f):
            r = f.get('radius', 0)
            length = 0
            if 'z_min' in f and 'z_max' in f:
                length = abs(f['z_max'] - f['z_min'])
            return length * r * r

        on_axis_cylinders.sort(key=volume_signature, reverse=True)
        main_cylinder = on_axis_cylinders[0]  # Largest volume signature

        logger.info(
            f"Position normalization using largest cylinder: "
            f"r={main_cylinder.get('radius', 0):.2f}, "
            f"pos=({main_cylinder.get('x_position', 0):.2f}, "
            f"{main_cylinder.get('y_position', 0):.2f})"
        )

        # Use this cylinder's position as the rotation axis center
        main_cylinders = [main_cylinder]

        # Calculate rotation axis center (centroid of main cylinder positions)
        if self.rotation_axis == 'z':
            center_x = sum(f['x_position'] for f in main_cylinders) / len(main_cylinders)
            center_y = sum(f['y_position'] for f in main_cylinders) / len(main_cylinders)
            center_z = 0  # z is axial, not radial
        elif self.rotation_axis == 'x':
            center_x = 0  # x is axial
            center_y = sum(f['y_position'] for f in main_cylinders) / len(main_cylinders)
            center_z = sum(f.get('z_position', 0) for f in main_cylinders if 'z_position' in f) / len(main_cylinders)
        elif self.rotation_axis == 'y':
            center_x = sum(f['x_position'] for f in main_cylinders) / len(main_cylinders)
            center_y = 0  # y is axial
            center_z = sum(f.get('z_position', 0) for f in main_cylinders if 'z_position' in f) / len(main_cylinders)
        else:
            return features

        logger.info(
            f"Rotation axis center: ({center_x:.2f}, {center_y:.2f}, {center_z:.2f})"
        )

        # Translate all feature positions
        for f in features:
            if 'x_position' in f:
                f['x_position'] = round(f['x_position'] - center_x, 3)
            if 'y_position' in f:
                f['y_position'] = round(f['y_position'] - center_y, 3)
            if 'z_position' in f:
                f['z_position'] = round(f['z_position'] - center_z, 3)

        return features

    def _detect_rotation_axis(self) -> Optional[str]:
        """
        Detect if part is rotational and determine axis.

        Two-stage detection:
        1. Majority vote (≥60%): if most surface axes align → that's the rotation axis.
           Handles simple parts with milled flats (minority off-axis features).
        2. Largest diameter fallback: if no majority, the axis of the LARGEST
           cylindrical surface is the rotation axis (the main body).
           Handles complex parts with many cross-holes/pockets (e.g., JR 810666).

        Returns: 'z', 'x', 'y', or None for non-rotational
        """
        # Collect axis directions AND radii from cylindrical and conical surfaces
        axis_entries = []  # List of (axis_direction, radius)

        for entity_id, entity in self.entities.items():
            entity_type = entity['type']
            if entity_type not in ('CYLINDRICAL_SURFACE', 'CONICAL_SURFACE'):
                continue

            params = entity['params']
            refs = re.findall(r'#\d+', params)
            if not refs:
                continue

            placement_id = self._resolve_ref(refs[0])
            if not placement_id:
                continue

            placement = self._resolve_placement(placement_id)
            if not placement or 'axis' not in placement:
                continue

            axis_dir = placement['axis']
            if not axis_dir:
                continue

            # Extract radius from params
            numbers = re.findall(r'(\d+\.?\d*)', params)
            radius = float(numbers[-1]) if numbers else 0.0
            if entity_type == 'CONICAL_SURFACE' and len(numbers) >= 2:
                radius = float(numbers[-2])  # Last number is semi_angle for cones

            axis_entries.append((axis_dir, radius))

        if not axis_entries:
            return None

        # Axis classification helpers
        def classify_axis(ax):
            if abs(ax[0]) < 0.1 and abs(ax[1]) < 0.1 and abs(abs(ax[2]) - 1.0) < 0.1:
                return 'z'
            if abs(abs(ax[0]) - 1.0) < 0.1 and abs(ax[1]) < 0.1 and abs(ax[2]) < 0.1:
                return 'x'
            if abs(ax[0]) < 0.1 and abs(abs(ax[1]) - 1.0) < 0.1 and abs(ax[2]) < 0.1:
                return 'y'
            return None

        total = len(axis_entries)

        # Stage 1: Majority vote (60% threshold)
        counts = {'x': 0, 'y': 0, 'z': 0}
        for ax_dir, _r in axis_entries:
            label = classify_axis(ax_dir)
            if label:
                counts[label] += 1

        best_axis = max(counts.items(), key=lambda x: x[1])
        if best_axis[1] / total >= 0.60:
            return best_axis[0]

        # Stage 2: Largest diameter wins
        # The axis of the largest cylindrical surface is the main body
        max_r_per_axis = {'x': 0.0, 'y': 0.0, 'z': 0.0}
        for ax_dir, radius in axis_entries:
            label = classify_axis(ax_dir)
            if label:
                max_r_per_axis[label] = max(max_r_per_axis[label], radius)

        best_by_size = max(max_r_per_axis.items(), key=lambda x: x[1])
        if best_by_size[1] > 0:
            # Additional check: the largest surface must be significantly bigger
            # than the second largest axis (at least 1.3x) to be confident
            sorted_axes = sorted(max_r_per_axis.items(), key=lambda x: -x[1])
            largest_r = sorted_axes[0][1]
            second_r = sorted_axes[1][1] if len(sorted_axes) > 1 else 0
            if second_r == 0 or largest_r / second_r >= 1.3:
                logger.info(
                    f"Rotation axis detected by largest diameter: "
                    f"{best_by_size[0]} (Ø{best_by_size[1]*2:.1f}mm vs "
                    f"second Ø{second_r*2:.1f}mm)"
                )
                return best_by_size[0]

        return None

    def _extract_face_boundaries(self):
        """
        Extract exact z_min/z_max boundaries for each surface
        by tracing ADVANCED_FACE → EDGE_LOOP → EDGE_CURVE → VERTEX_POINT.

        Axis-aware: uses self.rotation_axis to determine which vertex
        coordinate is the axial position (z) and which form the radius.
        - axis='z' → z=v[2], r=sqrt(v[0]²+v[1]²)
        - axis='x' → z=v[0], r=sqrt(v[1]²+v[2]²)
        - axis='y' → z=v[1], r=sqrt(v[0]²+v[2]²)

        Populates self.face_boundaries: {surface_id: {z_min, z_max, r_values}}
        """
        self.face_boundaries = {}
        axis = getattr(self, 'rotation_axis', None) or 'z'

        # Axis index mapping: which coordinate is axial
        axis_map = {'x': 0, 'y': 1, 'z': 2}
        ax_idx = axis_map.get(axis, 2)
        # Radial indices: the other two coordinates
        rad_indices = [i for i in range(3) if i != ax_idx]

        for face_id, face_data in self.advanced_faces.items():
            af_entity = self.entities.get(face_data['face_id'])
            if not af_entity:
                continue

            vertices = self._collect_face_vertices(af_entity)
            if not vertices:
                continue

            z_vals = [round(v[ax_idx], 3) for v in vertices]
            r_vals = [round(math.sqrt(v[rad_indices[0]]**2 + v[rad_indices[1]]**2), 3) for v in vertices]

            # Build z→r mapping from vertex pairs
            zr_map = {}
            for v in vertices:
                z = round(v[ax_idx], 3)
                r = round(math.sqrt(v[rad_indices[0]]**2 + v[rad_indices[1]]**2), 3)
                if z not in zr_map:
                    zr_map[z] = set()
                zr_map[z].add(r)
            # Convert to sorted list of (z, r) with unique z→max_r
            boundary_zr_pairs = []
            for z in sorted(zr_map.keys()):
                # Take max r for each z (outer contour convention)
                boundary_zr_pairs.append((z, max(zr_map[z])))

            self.face_boundaries[face_id] = {
                'z_min': min(z_vals),
                'z_max': max(z_vals),
                'r_values': sorted(set(r_vals)),
                'z_values': sorted(set(z_vals)),
                'boundary_zr_pairs': boundary_zr_pairs,
            }

    def _collect_face_vertices(self, af_entity: Dict) -> List[Tuple[float, float, float]]:
        """Collect all vertex points from an ADVANCED_FACE's edge loops."""
        vertices = []
        af_refs = re.findall(r'#(\d+)', af_entity['params'])

        for ref_str in af_refs:
            ref_id = int(ref_str)
            entity = self.entities.get(ref_id)
            if not entity:
                continue

            # FACE_BOUND / FACE_OUTER_BOUND → EDGE_LOOP
            if entity['type'] in ('FACE_BOUND', 'FACE_OUTER_BOUND'):
                loop_refs = re.findall(r'#(\d+)', entity['params'])
                if loop_refs:
                    entity = self.entities.get(int(loop_refs[0]))
                    if not entity:
                        continue

            if not entity or entity['type'] != 'EDGE_LOOP':
                continue

            # EDGE_LOOP → ORIENTED_EDGEs
            oe_refs = re.findall(r'#(\d+)', entity['params'])
            for oe_ref in oe_refs:
                oe = self.entities.get(int(oe_ref))
                if not oe or oe['type'] != 'ORIENTED_EDGE':
                    continue

                # ORIENTED_EDGE → EDGE_CURVE (refs after * markers)
                ec_refs = re.findall(r'#(\d+)', oe['params'])
                for ec_ref in ec_refs:
                    verts = self._get_edge_curve_vertices(int(ec_ref))
                    vertices.extend(verts)

        return vertices

    def _get_edge_curve_vertices(self, edge_curve_id: int) -> List[Tuple[float, float, float]]:
        """Get vertex points from an EDGE_CURVE entity."""
        ec = self.entities.get(edge_curve_id)
        if not ec or ec['type'] != 'EDGE_CURVE':
            return []

        refs = re.findall(r'#(\d+)', ec['params'])
        result = []

        for ref in refs[:2]:  # First 2 refs are VERTEX_POINT
            vp = self.entities.get(int(ref))
            if not vp or vp['type'] != 'VERTEX_POINT':
                continue
            cp_refs = re.findall(r'#(\d+)', vp['params'])
            if cp_refs:
                pt = self._resolve_cartesian_point(int(cp_refs[0]))
                if pt:
                    result.append(pt)

        return result

    def _extract_features(self) -> List[Dict]:
        """Extract manufacturing features from STEP entities"""

        # Detect rotation axis FIRST — needed for axis-aware boundary extraction
        self.rotation_axis = self._detect_rotation_axis()

        # Then extract face boundaries using the correct axis
        self._extract_face_boundaries()

        features = []

        # Look for common manufacturing features
        for entity_id, entity in self.entities.items():
            entity_type = entity['type']

            # CYLINDRICAL_SURFACE → potential hole or cylinder
            if entity_type == 'CYLINDRICAL_SURFACE':
                feature = self._parse_cylindrical_surface(entity)
                if feature:
                    features.append(feature)

            # CIRCLE → hole diameter
            elif entity_type == 'CIRCLE':
                feature = self._parse_circle(entity)
                if feature:
                    features.append(feature)

            # CONICAL_SURFACE → cone/taper
            elif entity_type == 'CONICAL_SURFACE':
                feature = self._parse_conical_surface(entity)
                if feature:
                    features.append(feature)

            # TOROIDAL_SURFACE → radius/fillet
            elif entity_type == 'TOROIDAL_SURFACE':
                feature = self._parse_toroidal_surface(entity)
                if feature:
                    features.append(feature)

        # Enrich with face boundary data (exact z_min/z_max from vertices)
        for feature in features:
            eid = feature.get('entity_id')
            if eid and eid in self.face_boundaries:
                bounds = self.face_boundaries[eid]
                feature['z_min'] = bounds['z_min']
                feature['z_max'] = bounds['z_max']
                feature['boundary_r_values'] = bounds['r_values']
                if 'boundary_zr_pairs' in bounds:
                    feature['boundary_zr_pairs'] = bounds['boundary_zr_pairs']

        # Normalize positions relative to rotation axis center
        features = self._normalize_positions(features)

        # Deduplicate using shared utility
        return deduplicate_features(features)

    def _parse_cylindrical_surface(self, entity: Dict) -> Optional[Dict]:
        """Parse cylindrical surface (hole or shaft) with position and inner/outer classification"""

        # Extract radius and placement reference
        # Format: CYLINDRICAL_SURFACE('', #placement, radius)
        params = entity['params']

        # Get placement reference (first #ID)
        refs = re.findall(r'#\d+', params)
        placement_id = self._resolve_ref(refs[0]) if refs else None

        # Find last number (radius)
        numbers = re.findall(r'(\d+\.?\d*)', params)
        if not numbers:
            return None

        radius = float(numbers[-1])
        diameter = radius * 2

        # Resolve placement to get position
        z_position = None
        x_position = None
        y_position = None
        axis_direction = None

        if placement_id:
            placement = self._resolve_placement(placement_id)
            if placement:
                if 'location' in placement and placement['location']:
                    x, y, z = placement['location']
                    z_position = round(z, 3)
                    x_position = round(x, 3)
                    y_position = round(y, 3)
                if 'axis' in placement and placement['axis']:
                    axis_direction = placement['axis']

        # Check if this surface is inner or outer
        is_inner = False
        if entity['id'] in self.advanced_faces:
            face_data = self.advanced_faces[entity['id']]
            is_inner = (face_data['sense'] == 'F')

        result = {
            'type': 'cylindrical',
            'diameter': round(diameter, 2),
            'radius': round(radius, 2),
            'entity_id': entity['id'],
            'placement_id': placement_id,
            'confidence': 1.0
        }

        if z_position is not None:
            result['z_position'] = z_position
        if x_position is not None and abs(x_position) > 0.001:
            result['x_position'] = x_position
        if y_position is not None and abs(y_position) > 0.001:
            result['y_position'] = y_position
        if axis_direction:
            result['axis_direction'] = axis_direction
        if is_inner:
            result['is_inner'] = True

        return result

    def _parse_circle(self, entity: Dict) -> Optional[Dict]:
        """Parse circle (cross-section of hole)"""

        params = entity['params']
        numbers = re.findall(r'(\d+\.?\d*)', params)

        if not numbers:
            return None

        radius = float(numbers[-1])
        diameter = radius * 2

        return {
            'type': 'hole',
            'diameter': round(diameter, 2),
            'entity_id': entity['id'],
            'confidence': 1.0
        }

    def _parse_conical_surface(self, entity: Dict) -> Optional[Dict]:
        """Parse conical surface (taper/chamfer) with position and direction"""

        # CONICAL_SURFACE('', #placement, radius, semi_angle)
        params = entity['params']

        # Get placement reference
        refs = re.findall(r'#\d+', params)
        placement_id = self._resolve_ref(refs[0]) if refs else None

        numbers = re.findall(r'(\d+\.?\d*)', params)

        if len(numbers) < 2:
            return None

        radius = float(numbers[-2])
        semi_angle_deg = float(numbers[-1])

        # IMPORTANT: Angle is already in degrees for AP203 files with CONVERSION_BASED_UNIT
        # Do NOT convert with math.degrees() - that was the bug!
        angle_deg = semi_angle_deg

        # Resolve placement to get position
        z_position = None
        axis_direction = None

        if placement_id:
            placement = self._resolve_placement(placement_id)
            if placement:
                if 'location' in placement and placement['location']:
                    x, y, z = placement['location']
                    z_position = round(z, 3)
                if 'axis' in placement and placement['axis']:
                    axis_direction = placement['axis']

        result = {
            'type': 'cone',
            'angle': round(angle_deg, 1),
            'radius': round(radius, 2),
            'entity_id': entity['id'],
            'placement_id': placement_id,
            'confidence': 1.0
        }

        if z_position is not None:
            result['z_position'] = z_position
        if axis_direction:
            result['axis_direction'] = axis_direction

        return result

    def _parse_toroidal_surface(self, entity: Dict) -> Optional[Dict]:
        """Parse toroidal surface (radius/fillet) with position"""

        # TOROIDAL_SURFACE('', #placement, major_radius, minor_radius)
        params = entity['params']

        # Get placement reference
        refs = re.findall(r'#\d+', params)
        placement_id = self._resolve_ref(refs[0]) if refs else None

        numbers = re.findall(r'(\d+\.?\d*)', params)

        if len(numbers) < 2:
            return None

        major_radius = float(numbers[-2])
        minor_radius = float(numbers[-1])

        # Resolve placement to get position
        z_position = None

        if placement_id:
            placement = self._resolve_placement(placement_id)
            if placement and 'location' in placement and placement['location']:
                x, y, z = placement['location']
                z_position = round(z, 3)

        # Check if this surface is inner or outer
        is_inner = False
        if entity['id'] in self.advanced_faces:
            face_data = self.advanced_faces[entity['id']]
            is_inner = (face_data['sense'] == 'F')

        result = {
            'type': 'radius',
            'radius': round(minor_radius, 2),
            'major_radius': round(major_radius, 2),
            'minor_radius': round(minor_radius, 2),
            'entity_id': entity['id'],
            'placement_id': placement_id,
            'confidence': 1.0
        }

        if z_position is not None:
            result['z_position'] = z_position
        if is_inner:
            result['is_inner'] = True

        return result

    def _extract_metadata(self, content: str) -> Dict:
        """Extract file metadata from HEADER section"""

        metadata = {}

        # FILE_DESCRIPTION
        desc_match = re.search(r"FILE_DESCRIPTION\s*\(\s*\('([^']+)'", content)
        if desc_match:
            metadata['description'] = desc_match.group(1)

        # FILE_NAME
        name_match = re.search(r"FILE_NAME\s*\(\s*'([^']+)'", content)
        if name_match:
            metadata['file_name'] = name_match.group(1)

        # SCHEMA
        schema_match = re.search(r"FILE_SCHEMA\s*\(\s*\('([^']+)'", content)
        if schema_match:
            metadata['schema'] = schema_match.group(1)

        # Originating system
        origin_match = re.search(r"preprocessor_version\s*,\s*'([^']+)'", content)
        if origin_match:
            metadata['origin_system'] = origin_match.group(1)

        return metadata

    def get_summary(self, features: List[Dict]) -> Dict:
        """Summarize features for quick overview"""

        summary = {
            'holes': [],
            'threads': [],
            'cones': [],
            'radii': [],
            'total_features': len(features)
        }

        for feature in features:
            if feature['type'] == 'hole':
                summary['holes'].append(f"Ø{feature['diameter']}")
            elif feature['type'] == 'cone':
                summary['cones'].append(f"{feature['angle']}°")
            elif feature['type'] == 'radius':
                summary['radii'].append(f"R{feature['radius']}")

        return summary


class ClaudeStepParser:
    """
    Advanced STEP parsing using Claude API
    Use when basic text parsing fails or for complex geometry
    """

    def __init__(self, anthropic_api_key: str):
        from anthropic import Anthropic
        from app.services.claude_utils import parse_claude_json_response
        self.client = Anthropic(api_key=anthropic_api_key)
        self._parse_response = parse_claude_json_response

    async def parse_step_with_claude(self, step_path: str, pdf_context: Optional[str] = None) -> Dict:
        """
        Parse STEP using Claude API

        Claude can read STEP text format and extract geometry intelligently
        """

        # Read STEP file (it's text)
        content = Path(step_path).read_text(encoding='utf-8', errors='ignore')

        # Limit size (STEP can be huge)
        if len(content) > 100000:
            # Extract just DATA section for large files
            data_match = re.search(r'DATA;(.*?)ENDSEC;', content, re.DOTALL)
            if data_match:
                content = f"HEADER;\n...(truncated)\nDATA;\n{data_match.group(1)[:50000]}\n...(truncated)"

        # Build prompt
        prompt = self._build_step_analysis_prompt(content, pdf_context)

        # Call Claude
        response = self.client.messages.create(
            model="claude-sonnet-4-5-20250929",
            max_tokens=4096,
            messages=[{
                "role": "user",
                "content": prompt
            }]
        )

        # Parse response
        return self._parse_claude_step_response(response.content)

    def _build_step_analysis_prompt(self, step_content: str, pdf_context: Optional[str]) -> str:
        """Build prompt for Claude to analyze STEP file"""

        context_section = ""
        if pdf_context:
            context_section = f"""
PDF DRAWING CONTEXT (for annotations/tolerances):
{pdf_context}

Use PDF for:
- Material specification
- Surface treatment
- Tolerances (H7, ISO 2768, etc.)
- Thread specifications
"""

        return f"""
Analyzuj tento STEP soubor (ISO 10303-21) a extrahuj PŘESNÉ výrobní features.

STEP JE SOURCE OF TRUTH pro geometrii!

{context_section}

STEP CONTENT:
{step_content[:20000]}

ÚKOL:
Extrahuj manufacturing features (holes, threads, chamfers, cones, radii) s PŘESNÝMI rozměry ze STEP geometrie.

OUTPUT (JSON):
{{
  "features": [
    {{
      "type": "hole",
      "diameter": 19.0,
      "depth": 89.0,
      "through": true,
      "position": "center_axis",
      "source": "CIRCLE entity #123, CYLINDRICAL_SURFACE #456"
    }},
    {{
      "type": "thread",
      "spec": "M30×2",
      "length": 77.5,
      "diameter": 30.0,
      "source": "STEP geometry + PDF annotation"
    }},
    {{
      "type": "cone",
      "angle": 31.2,
      "from_radius": 15.0,
      "to_radius": 13.5,
      "length": 12.5,
      "source": "CONICAL_SURFACE #789"
    }}
  ],
  "bounding_box": {{
    "height": 89.0,
    "diameter_max": 55.0
  }},
  "precision_notes": "All dimensions from STEP geometry, accurate to 0.1mm"
}}

CRITICAL:
- Extract NUMERICAL values from STEP entities
- Rozliš průchozí vs. slepé díry (check depth vs. total height)
- Závity kombinuj: STEP geometry + PDF text annotations
"""

    def _parse_claude_step_response(self, content) -> Dict:
        """Parse Claude's response using shared utility"""
        result = self._parse_response(content)
        if isinstance(result, dict):
            return result
        return {'raw_response': str(content), 'success': False}


class StepPdfMerger:
    """
    Merge STEP (precise geometry) + PDF (annotations, tolerances)

    TOHLE JE KLÍČ - STEP dává přesnost, PDF kontext!
    """

    def __init__(self, claude_api_key: str):
        self.step_parser = StepParser()
        self.claude_step_parser = ClaudeStepParser(claude_api_key)

    async def merge_step_pdf(
        self,
        step_path: str,
        pdf_path: Optional[str] = None,
        svg_analysis: Optional[Dict] = None
    ) -> Dict:
        """
        Merge STEP + PDF for maximum accuracy

        STEP = truth for geometry
        PDF/SVG = annotations, material, tolerances
        """

        # 1. Parse STEP (basic)
        step_result = self.step_parser.parse_file(step_path)

        # 2. Get PDF context (from previous SVG/PDF analysis)
        pdf_context = None
        if svg_analysis:
            pdf_context = {
                'material': svg_analysis.get('metadata', {}).get('material_grade'),
                'surface_treatment': svg_analysis.get('metadata', {}).get('surface_treatment'),
                'tolerances': svg_analysis.get('metadata', {}).get('tolerance_standard'),
                'annotations': [f['raw_text'] for f in svg_analysis.get('features', [])]
            }

        # 3. If basic STEP parsing not enough → use Claude
        if not step_result.get('success') or len(step_result.get('features', [])) < 3:
            logger.info("Basic STEP parsing insufficient → using Claude API for deep analysis")
            step_result = await self.claude_step_parser.parse_step_with_claude(
                step_path,
                pdf_context=str(pdf_context) if pdf_context else None
            )

        # 4. Merge results
        merged = {
            'geometry': step_result.get('features', []),
            'metadata': {
                **(step_result.get('metadata', {})),
                **(pdf_context or {})
            },
            'confidence': 0.95,  # High confidence (STEP verified)
            'source': 'step_pdf_merge',
            'auto_verified': True  # STEP je auto-verification!
        }

        return merged
